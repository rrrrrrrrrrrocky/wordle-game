# 프로젝트 설명

- 운영 페이지: https://game.rrrrrrrrrrr.xyz/

## 기술 스택

- 메인 프레임워크: Next.js (App Router 기반)
- 스타일링: Tailwind CSS, Radix UI, Shadcn
- 상태 관리: Zustand
- 비동기 상태 관리 & API 요청: Axios, React Query
- 패키지 매니저: pnpm
- 코드 스타일 & 린팅: ESLint, Prettier
- 형상 관리: Git, GitHub

## 프로젝트 시작하기

```bash
pnpm i --frozen-lockfile && pnpm dev
```

`pnpm dev` 구문에는 `echo CRYPTO_SECRET_KEY=test-key > .env` 구문이 포함되어있습니다.

## 폴더구조

### 컨벤션

> 1. 폴더는 단수 / 파일은 export 및 로직에 맞게 단/복수를 처리합니다.
> 2. 모든 폴더, 파일은 케밥케이스로 작성합니다.
> 3. 컨테이너 컴포넌트는 prefix로 언더바 처리합니다.

#### `/public`

- 폰트, 이미지, 로고 등 스태틱한 리소스를 관리합니다.

#### `/src/app`

- Next.js App Router를 사용한 페이지 라우팅을 관리합니다.

#### `/src/component`

- `ui/`: shadcn의 컴포넌트가 보관되는 곳이며, 재사용 가능한 UI 컴포넌트를 관리합니다.
- `_common/`: 공통되게 (2곳 이상) 사용되는 컴포넌트들의 집합입니다.
- `[...components]/`: 하나의 페이지에서 사용되는 컴포넌트입니다.
  (규모가 커질 경우, Next.js App Router 규칙에 맞게 라우팅 기반의 폴더 하위로 귀속시킬 수 있습니다.)

#### `/src/resource`

- `style/`: 스타일시트를 관리합니다.

#### `/src/script`

- `api/`: React-query의 비동기 훅을 관리합니다.
- `config/`: 환경설정(axios, build-target 등)을 관리합니다.
- `constant/`: 상수를 관리합니다.
- `dto/`: 데이터 전송(서버 요청/응답)에 관한 인터페이스르 관리합니다.
- `hook/`: 비즈니스 로직 및 hook기반의 스토어(zustand)를 관리합니다.
- `type/`: 전체적인 타입은 해당 파일에서 관리하지만 전역, 공통으로 처리가 필요한 타입을 분리해서 관리합니다.
- `util/`: 서비스, 공통로직, 파싱, 정규식 등 공통되게 사용되는 함수를 적절히 분리하여 관리합니다.

## 프로젝트 구조

### 페이지

총 페이지는 `메인`, `샘플페이지`, `암호화된 답변으로 이루어진 동적 페이지`로 이루어져 있습니다.

#### 1. 홈 (/)

- `시작하기(샘플 게임)`, `워들 생성하기`, `랜덤 단어로 게임하기`의 페이지 혹은 다이얼로그를 띄울 수 있는 버튼 제공

#### 2. 샘플페이지 (/example)

- 'WORLD'라는 답을 맞춰 볼 수 있는 샘플페이지 (`시작하기(샘플 게임)`의 버튼을 누르면 진입 가능)

#### 3. 암호화된 답변으로 이루어진 동적 페이지 (/[answer])

- `워들 생성하기`, `랜덤 단어로 게임하기` 버튼을 누르면 진입 할 수 있는 페이지
- `워들 생성하기`: 사용자가 직접 인풋에 단어를 입력하면 사전API를 통해 검증 후 Next.js 서버에 만들어둔 api를 사용하여 암호화합니다.
- `랜덤 단어로 게임하기`: Next.js 서버에 만들어둔 api에 [랜덤API](https://random-word-api.herokuapp.com/word?length=5&number=1)를 임시로 사용하여 `응답 -> 사전API 검증 -> 암호화 -> 페이지이동` 순으로 처리 후 이동합니다.

#### 핵심 비즈니스 플로우

1. 최초 마운트 시, URL에 암호화된 정답을 복호화하여 localStorage에 진행중인 게임인지 확인하고 진행중이라면 기존의 데이터를 보드에 동기화합니다.
2. 5\*6의 row를 하나의 도전(challenge)로 정의하고, 각 도전의 제출 때 마다 `정답`, `오답`을 체크합니다.
3. 6번의 기회 중에 정답을 맞추면 n번째 도전에 카운트 되고, 사용자가 집계데이터를 볼 수 있습니다.
4. 6번의 기회 중에 정답을 맞추지 못하면 fail로 집계가 됩니다.
5. 정답, 오답 여부 상관없이 최종 제출된 게임은 localStorage에 히스토리로 기록됩니다.
6. 결과 다이얼로그가 닫히거나 새로고침되면 모든 상태가 초기화되면서 홈으로 이동합니다.

#### 데이터 흐름

- `use-game-controller`: 게임 진행 시, 주요 비즈니스 로직을 `use-game-store`의 데이터로 처리합니다.
- `use-game-stat-controller`: 게임 진행 완료 혹은 임시저장과 같은 로직을 `use-game-stat-persist-store`의 데이터를 처리하고, 해당 데이터는 브라우저의 localStorage에 저장됩니다.

## 해결해야 했던 문제

### 1. 암호화/복호화에 대한 처리

처음 기술스택 선정 시, 키관리가 필요없는 단방향 해시로 정답여부만 확인하면 되지 않을까라는 생각에 React로 선정하려했으나
정답과 제출한 답을 검증하는 과정이 필요하기에 암호화/복호화를 할 수 있는 양방향 암호화 알고리즘을 채택하였고,
클라이언트는 키 노출의 우려가 있기에 서버에서 처리 할 수 있는 Next.js로 선정하였습니다.
최초의 고민에서는 Next.js가 오버스펙이지 않을까라는 고민을 하였지만 결과적으로는 올바른 선택이었다고 생각됩니다.

### 2. 비즈니스 로직에 대한 고민

현재 구현된 `워들 생성하기`, `랜덤 단어로 게임하기` 기능은 '내가 사용자라면..' 입장으로 생각해봤을 때
출제자의 입장 뿐만 아니라 본인도 풀어보고 싶을 것이라는 생각에 두가지 기능을 모두 추가하였고,
진입과정이 다를 뿐 게임을 하며 즐기는 경험은 공통되도록 처리하기 위해 고민하였습니다.

### 3. 렌더링 최적화에 대한 고민

최초에는 2차원 배열로 구성된 보드 및 키보드의 리렌더링이 부담이 될 것 같아서
현재 구현된 방식(zustand의 전역상태를 관리하며 UI,로직 처리)에서 렌더링은 DOM에 이관하고,
비즈니스 로직은 Virtual DOM으로 처리하려 하였습니다.

하지만 작업중에 x,y 포지션 관리, 부모에게 데이터 전달 등의 작업이 유지보수에 있어서 적절해 보이지 않았고,
현재 서비스 규모에서는 불필요한 작업일 것이라 생각하여 메모이제이션을 적절히하여 최적화하였습니다.

## 다음 목표 (향후 프로젝트에서 적용할 개선 사항)

- `랜덤 단어로 게임하기` 공유하기 기능 추가 + SNS 공유 기능 추가
- 제출했던 단어 중 사전API에서 없는 단어들도 localStorage에 저장해서 API호출 감소
- 적절한 애니메이션 추가
- 결과 다이얼로그 UI 개선
- 게임 데이터 분석 및 통계 저장 고도화 (로그인 기능 추가 후 개인 별 통계 제공, 평균 게임 시간, 다른사람과 승률비교 등)
